"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[4797],{9163:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>m});var i=s(5893),n=s(1151);const a={title:"6_OptimalNumberOfStates",description:"The script used to determine the optimum number of states.",sidebar_position:1},o="6_OptimalNumberOfStates",r={id:"ChromOptimise/Pipeline-Explanation/OptimalNumberOfStates/OptimalNumberOfStates",title:"6_OptimalNumberOfStates",description:"The script used to determine the optimum number of states.",source:"@site/docs/ChromOptimise/Pipeline-Explanation/OptimalNumberOfStates/6_OptimalNumberOfStates.md",sourceDirName:"ChromOptimise/Pipeline-Explanation/OptimalNumberOfStates",slug:"/ChromOptimise/Pipeline-Explanation/OptimalNumberOfStates/OptimalNumberOfStates",permalink:"/ChromOptimise/ChromOptimise/Pipeline-Explanation/OptimalNumberOfStates/OptimalNumberOfStates",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"6_OptimalNumberOfStates",description:"The script used to determine the optimum number of states.",sidebar_position:1},sidebar:"documentationSidebar",previous:{title:"Optimal Number of States",permalink:"/ChromOptimise/category/optimal-number-of-states"},next:{title:"SimilarEmissions",permalink:"/ChromOptimise/ChromOptimise/Pipeline-Explanation/OptimalNumberOfStates/SimilarEmissions"}},l={},m=[{value:"Explanation",id:"explanation",level:2},{value:"Thresholds",id:"thresholds",level:2},{value:"The curse of dimensionality",id:"the-curse-of-dimensionality",level:3},{value:"Example usage",id:"example-usage",level:2}];function h(e){const t={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",math:"math",mfrac:"mfrac",mn:"mn",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,n.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"6_optimalnumberofstates",children:"6_OptimalNumberOfStates"}),"\n",(0,i.jsx)(t.h2,{id:"explanation",children:"Explanation"}),"\n",(0,i.jsx)(t.p,{children:"This is the wrapper script that will parse your arguments into mutliple R scripts in order to determine redundant states. It starts with the most complex model and works its way down until a model with no redundant states is found. This model is classed as being optimal."}),"\n",(0,i.jsx)(t.admonition,{title:"Max model number",type:"note",children:(0,i.jsx)(t.p,{children:"There is a possible source of error in the above logic where the output will not actually be the optimal number of states to use. Suppose the maximum number of states out of any model is only 3 (but the number of marks is much larger than this), then it is likely that this model has no redundant states. This doesn't actually suggests that the optimal number of states is 3, just that it is 3 or greater. The additional information of a model with 4 states having redundant states is what confirms the model with 3 states is optimal."})}),"\n",(0,i.jsx)(t.p,{children:"Note that you still need to input the bin size, sample size and the number of models learned here. The reason for this is because the file structure is designed such that multiple runs of the same dataset can be analysed concurrently."}),"\n",(0,i.jsx)(t.h2,{id:"thresholds",children:"Thresholds"}),"\n",(0,i.jsxs)(t.p,{children:["The major factor that affects the output of this script lies in the thresholds defined in the configuration file for R ",(0,i.jsx)(t.a,{href:"/ChromOptimise/ChromOptimise/Configuration-Files-Setup#configr",children:"config.R"}),". It can be difficult to determine suitable values for these thresholds without prior knowledge. To help with this, the supplementary pipeline was created. Running the supplementary pipeline can help the user in identifying 'good' values for these thresholds based off of the information gained from much larger models (that undoubtedly have redundant states). To learn more about this pipeline, consult ",(0,i.jsx)(t.a,{href:"/category/supplementary-pipeline---usage-and-explanation",children:"these pages"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"the-curse-of-dimensionality",children:"The curse of dimensionality"}),"\n",(0,i.jsxs)(t.p,{children:["The threshold for isolation scores is likely to be similar across datasets, but the value for ",(0,i.jsx)(t.code,{children:"emissions_threshold"})," will not. This threshold determines when two states are 'too similar' in terms of their emission parameters (according to the Euclidean distance metric)."]}),"\n",(0,i.jsx)(t.p,{children:"Different datasets with differing numbers of marks will certainly require different values for this threshold. The reason for this is as follows: The number of marks is the dimension of the emission parameter vectors (the number of columns in the emission files). As you add more dimensions to a vector space, the distance between two random vectors is also expected to increase. It becomes increasingly difficult for two random vectors to be 'very close' to one another."}),"\n",(0,i.jsxs)(t.p,{children:["Consider a line of length 1 meter. Pick two random points on the line and at a maximum they can be 1 meter from one another. The expected distance between the points will be 0.5 meters (hopefully this is obvious). Now suppose you have a square with side lengths 1. When you place two points inside this square at random, then the expected distance between them is now ",(0,i.jsxs)(t.span,{className:"katex",children:[(0,i.jsx)(t.span,{className:"katex-mathml",children:(0,i.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(t.semantics,{children:[(0,i.jsx)(t.mrow,{children:(0,i.jsxs)(t.mfrac,{children:[(0,i.jsx)(t.mn,{children:"2"}),(0,i.jsx)(t.mn,{children:"3"})]})}),(0,i.jsx)(t.annotation,{encoding:"application/x-tex",children:"\\frac{2}{3}"})]})})}),(0,i.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(t.span,{className:"base",children:[(0,i.jsx)(t.span,{className:"strut",style:{height:"1.1901em",verticalAlign:"-0.345em"}}),(0,i.jsxs)(t.span,{className:"mord",children:[(0,i.jsx)(t.span,{className:"mopen nulldelimiter"}),(0,i.jsx)(t.span,{className:"mfrac",children:(0,i.jsxs)(t.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(t.span,{className:"vlist-r",children:[(0,i.jsxs)(t.span,{className:"vlist",style:{height:"0.8451em"},children:[(0,i.jsxs)(t.span,{style:{top:"-2.655em"},children:[(0,i.jsx)(t.span,{className:"pstrut",style:{height:"3em"}}),(0,i.jsx)(t.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(t.span,{className:"mord mtight",children:(0,i.jsx)(t.span,{className:"mord mtight",children:"3"})})})]}),(0,i.jsxs)(t.span,{style:{top:"-3.23em"},children:[(0,i.jsx)(t.span,{className:"pstrut",style:{height:"3em"}}),(0,i.jsx)(t.span,{className:"frac-line",style:{borderBottomWidth:"0.04em"}})]}),(0,i.jsxs)(t.span,{style:{top:"-3.394em"},children:[(0,i.jsx)(t.span,{className:"pstrut",style:{height:"3em"}}),(0,i.jsx)(t.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(t.span,{className:"mord mtight",children:(0,i.jsx)(t.span,{className:"mord mtight",children:"2"})})})]})]}),(0,i.jsx)(t.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(t.span,{className:"vlist-r",children:(0,i.jsx)(t.span,{className:"vlist",style:{height:"0.345em"},children:(0,i.jsx)(t.span,{})})})]})}),(0,i.jsx)(t.span,{className:"mclose nulldelimiter"})]})]})})]})," meters. In any one direction, the max distance is still 1 meter, but now there is a new dimension that the points can differ in, meaning the distance between them can be even larger than in the 1 dimensional case. This continues as you think about cubes and hyper cubes (",(0,i.jsx)(t.em,{children:"etc."}),")."]}),"\n",(0,i.jsxs)(t.p,{children:["As such, no value is given for the ",(0,i.jsx)(t.code,{children:"emission_threshold"}),", this value should be changed depending on the number of marks you have included in your dataset."]}),"\n",(0,i.jsx)(t.h2,{id:"example-usage",children:"Example usage"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:'# Generates metrics and heuristics for the models currently in ${MODEL_DIR}\n# and uses these to determine  the optimal number of states for the binarized\n# data set.\nsbatch 6_OptimalNumberOfStates.sh \\\n--config="path/to/configuration/directory" \\\n--chromosome=1 \\\n--binsize=200 \\\n--samplesize=75 \\\n--nummodels=6 \\\n'})})]})}function d(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},1151:(e,t,s)=>{s.d(t,{Z:()=>r,a:()=>o});var i=s(7294);const n={},a=i.createContext(n);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);