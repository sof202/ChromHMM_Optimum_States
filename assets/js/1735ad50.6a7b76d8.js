"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2790],{8772:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>m});var t=n(5893),o=n(1151);const s={sidebar_position:7},r="Memory profiling",a={id:"ChromOptimise/Memory-Profiling",title:"Memory profiling",description:"To gain insights into the peak heap consumption of each script in the pipeline,",source:"@site/docs/ChromOptimise/Memory-Profiling.md",sourceDirName:"ChromOptimise",slug:"/ChromOptimise/Memory-Profiling",permalink:"/ChromOptimise/ChromOptimise/Memory-Profiling",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"documentationSidebar",previous:{title:"Processing times",permalink:"/ChromOptimise/ChromOptimise/Processing-Times"},next:{title:"SLURM information",permalink:"/ChromOptimise/ChromOptimise/SLURM-Workload-Manager-Information"}},l={},m=[{value:"1_SubsampleBamFiles.sh",id:"1_subsamplebamfilessh",level:2},{value:"2_BinarizeBamFiles.sh",id:"2_binarizebamfilessh",level:2},{value:"3_batch_CreateIncrementalModels.sh",id:"3_batch_createincrementalmodelssh",level:2},{value:"4_OptimalNumberofStates.sh",id:"4_optimalnumberofstatessh",level:2},{value:"5_ReferenceLDSCore.sh",id:"5_referenceldscoresh",level:2},{value:"6_PartitionedHeritability.sh",id:"6_partitionedheritabilitysh",level:2},{value:"Generate_Big_Model.sh",id:"generate_big_modelsh",level:2}];function h(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"memory-profiling",children:"Memory profiling"}),"\n",(0,t.jsx)(i.p,{children:"To gain insights into the peak heap consumption of each script in the pipeline,\nwe utilized the tool Heaptrack. This allowed for the estimation of memory\nconsumption based on unit tests (albeit only with relatively small amounts of\ndata). Utilizing this information will empower the user to make well-informed\ndecisions regarding the allocation of memory for the scripts involved in the\npipeline and ChromHMM."}),"\n",(0,t.jsxs)(i.p,{children:["Heaptrack, produced by KDE, can be obtained through an appimage download or\nlocal compilation. The GitHub repository for Heaptrack can be accessed\n",(0,t.jsx)(i.a,{href:"https://github.com/KDE/heaptrack",children:"here"}),"."]}),"\n",(0,t.jsx)(i.h2,{id:"1_subsamplebamfilessh",children:"1_SubsampleBamFiles.sh"}),"\n",(0,t.jsxs)(i.p,{children:["This script is designed to utilize minimal memory when merging and subsampling\na small number of files. During the merging process, ",(0,t.jsx)(i.code,{children:"samtools merge"})," only\nopens a small component of each file being merged at a time, instead of opening\neach file in its entirety. The subsampling is carried out using ",(0,t.jsx)(i.code,{children:"samtools view"}),", which uses very little peak memory consumption relative to file size."]}),"\n",(0,t.jsxs)(i.p,{children:["However, challenges may arise when merging a significantly larger number of\nfiles. According to the\n",(0,t.jsx)(i.a,{href:"http://www.htslib.org/doc/samtools-merge.html",children:"documentation"})," for ",(0,t.jsx)(i.code,{children:"samtools merge"}),", the command utilizes ~1 MB of data from each file at a time. It's\nimportant to be mindful of this information when merging large numbers of files\nwithin the pipeline. In the event of memory-related errors with this script, it\nis recommended to execute ",(0,t.jsx)(i.code,{children:"ulimit -n"})," in the terminal to check the limit set on\nhow many files can be open at one time. If the number of files to merge exceeds\nthe output of ",(0,t.jsx)(i.code,{children:"ulimit -n"}),", it is advisable to consider modifying the script to\nmerge the files in batches instead of all at once."]}),"\n",(0,t.jsx)(i.h2,{id:"2_binarizebamfilessh",children:"2_BinarizeBamFiles.sh"}),"\n",(0,t.jsxs)(i.p,{children:["ChromHMM's ",(0,t.jsx)(i.code,{children:"BinarizeBam"})," command is the main contributor to memory consumption\nin this script."]}),"\n",(0,t.jsx)(i.p,{children:"In testing, the following was observed:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"For a directory with 16.8 GB of .bam files: peak heap memory consumption was\n40 MB"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"3_batch_createincrementalmodelssh",children:"3_batch_CreateIncrementalModels.sh"}),"\n",(0,t.jsxs)(i.p,{children:["ChromHMM's ",(0,t.jsx)(i.code,{children:"LearnModel"})," command is the main contributor to memory consumption\nin this script."]}),"\n",(0,t.jsx)(i.p,{children:"In testing, the following was observed:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Using binary files that were 1 MB in total:","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"2 state model training had 181 MB peak memory consumption"}),"\n",(0,t.jsx)(i.li,{children:"3 state model training had 145 MB peak memory consumption"}),"\n",(0,t.jsx)(i.li,{children:"4 state model training had 165 MB peak memory consumption"}),"\n",(0,t.jsx)(i.li,{children:"5 state model training had 128 MB peak memory consumption"}),"\n",(0,t.jsx)(i.li,{children:"6 state model training had 165 MB peak memory consumption"}),"\n",(0,t.jsx)(i.li,{children:"7 state model training had 168 MB peak memory consumption"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Based on the provided information, it is evident that the memory consumption is\nprimarily dependent on the total size of the binary files rather than the\nnumber of states used in the models."}),"\n",(0,t.jsx)(i.p,{children:"Additionally, it's important to note that this script is designed to be\nexecuted as an array through the SLURM workload manager. Therefore, the peak\nmemory consumption is anticipated to be proportional to the size of the largest\n.bam files multiplied by the number of array elements."}),"\n",(0,t.jsx)(i.h2,{id:"4_optimalnumberofstatessh",children:"4_OptimalNumberofStates.sh"}),"\n",(0,t.jsx)(i.p,{children:"This script utilizes Rscripts which entail minor computations, resulting in\nvery low memory consumption. Through testing, it has been observed that the\nmemory usage never surpassed a few kilobytes."}),"\n",(0,t.jsx)(i.h2,{id:"5_referenceldscoresh",children:"5_ReferenceLDSCore.sh"}),"\n",(0,t.jsx)(i.p,{children:"This script's biggest requirement of memory comes from the SNP assigment R\nscript that it calls. In testing, chromosomes 1 and 2 use about 800MB of\nmemory. Because the script is ran as an array that processes each chromosome at\nthe same time, 22 GB of memory is allocated."}),"\n",(0,t.jsx)(i.h2,{id:"6_partitionedheritabilitysh",children:"6_PartitionedHeritability.sh"}),"\n",(0,t.jsxs)(i.p,{children:["According to ",(0,t.jsx)(i.a,{href:"https://github.com/bulik/ldsc/wiki/FAQ",children:"ldsc's creators"}),",\npartitioned heritability should only take up ~8GB for 50 annotations. The number\nof annotations in this script will be greater than 50. In testing, over 20GB is\nrequired to stop out of memory errors for just 58 annotations. To account for\nthis, the SLURM directive is set to 50GB of memory."]}),"\n",(0,t.jsx)(i.h2,{id:"generate_big_modelsh",children:"Generate_Big_Model.sh"}),"\n",(0,t.jsxs)(i.p,{children:["This script is similar to\n",(0,t.jsx)(i.a,{href:"#3_batch_createincrementalmodelssh",children:"3_batch_CreateIncrementalModels.sh"}),",\nsuggesting that the memory consumption pattern is likely to align with the\nconclusions drawn there. However, it's important to note that due to the\ncomputational time required for this script, utilizing heaptrack to monitor\nmemory allocations was impractical. Consequently, the memory consumption for\nnotably large models (20 states or more) remains unknown and is not extensively\ndocumented."]})]})}function c(e={}){const{wrapper:i}={...(0,o.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},1151:(e,i,n)=>{n.d(i,{Z:()=>a,a:()=>r});var t=n(7294);const o={},s=t.createContext(o);function r(e){const i=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);