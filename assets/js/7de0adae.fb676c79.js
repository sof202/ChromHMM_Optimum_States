"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2763],{5172:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var i=t(5893),s=t(1151);const r={sidebar_position:8},o="SLURM information",a={id:"ChromOptimise/SLURM-Workload-Manager-Information",title:"SLURM information",description:"The scripts included in this repository were designed to be used with SLURM",source:"@site/docs/ChromOptimise/SLURM-Workload-Manager-Information.md",sourceDirName:"ChromOptimise",slug:"/ChromOptimise/SLURM-Workload-Manager-Information",permalink:"/ChromOptimise/ChromOptimise/SLURM-Workload-Manager-Information",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"documentationSidebar",previous:{title:"Memory profiling",permalink:"/ChromOptimise/ChromOptimise/Memory-Profiling"}},l={},d=[{value:"<code>#SBATCH</code> lines",id:"sbatch-lines",level:2},{value:"Log files The most important aspect that is lost when running scripts",id:"log-files-the-most-important-aspect-that-is-lost-when-running-scripts",level:2},{value:"SLURM environment variables",id:"slurm-environment-variables",level:2},{value:"Arrays",id:"arrays",level:2},{value:"Time and memory allocation",id:"time-and-memory-allocation",level:2},{value:"<code>module purge</code> and <code>module load</code>",id:"module-purge-and-module-load",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"slurm-information",children:"SLURM information"}),"\n",(0,i.jsxs)(n.p,{children:["The scripts included in this repository were designed to be used with SLURM\nworkload manager. As such, many elements of the scripts will not work if one\ndoes not run them through SLURM's ",(0,i.jsx)(n.code,{children:"sbatch"})," command."]}),"\n",(0,i.jsxs)(n.p,{children:["Here, we will outline the main areas of the code that depend on SLURM's\n",(0,i.jsx)(n.code,{children:"sbatch"})," command in order to function correctly."]}),"\n",(0,i.jsxs)(n.h2,{id:"sbatch-lines",children:[(0,i.jsx)(n.code,{children:"#SBATCH"})," lines"]}),"\n",(0,i.jsxs)(n.p,{children:["At the top of every script (after the shebang) there are\nseveral comment lines that start: ",(0,i.jsx)(n.code,{children:"#SBATCH"}),". These lines are read by SLURM and\ngive meta data on how the script should be ran. If running the script normally,\nthese lines will be interpreted as comments, resulting in loss of\nfunctionality."]}),"\n",(0,i.jsx)(n.h2,{id:"log-files-the-most-important-aspect-that-is-lost-when-running-scripts",children:"Log files The most important aspect that is lost when running scripts"}),"\n",(0,i.jsxs)(n.p,{children:["outside of ",(0,i.jsx)(n.code,{children:"sbatch"})," is the error logs. If one runs the scripts normally, all\noutputs, warnings and errors will be printed to the terminal."]}),"\n",(0,i.jsxs)(n.p,{children:["There will also be error messages from the hard links that are created in the\nSET UP section of each script. SLURM workload manager is unable to create\nfolders in ",(0,i.jsx)(n.code,{children:"#SBATCH"})," lines and naming of log files is limited. As a result, log\nfiles are generated under temporary names and a hard link is made with a file\nwith a more descriptive name (which allows for a more organised structure of\nyour log files)."]}),"\n",(0,i.jsx)(n.h2,{id:"slurm-environment-variables",children:"SLURM environment variables"}),"\n",(0,i.jsxs)(n.p,{children:["Certain aspects of the scripts may lose there\nfunctionality if they depend on environment variables that are set up when\nrunning the script with SLURM's ",(0,i.jsx)(n.code,{children:"sbatch"})," command. Common SLURM environment\nvariables that were used were:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"SLURM_SUBMIT_DIR -> This is the directory that the shell was in when the\nscript was initially ran,"}),"\n",(0,i.jsx)(n.li,{children:"SLURM_JOB_ID -> This is the unique job identification number assigned to the\njob at creation,"}),"\n",(0,i.jsxs)(n.li,{children:["SLURM_JOB_NAME -> This is the name of the job as defined in the ",(0,i.jsx)(n.code,{children:"#SBATCH"}),"\nlines."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Most instances of these variables are fine as they are not required for the\nscript to function"}),"\n",(0,i.jsx)(n.h2,{id:"arrays",children:"Arrays"}),"\n",(0,i.jsxs)(n.p,{children:["For scripts that start with 'batch', the job is designed to be ran as\na SLURM array (enabling parallelisation). If one does not run these scripts as\nan array through ",(0,i.jsx)(n.code,{children:"sbatch [script] --array=1-4"})," etc. then the script will fail.\nThis is because the parallel processing logic that is applied in these scripts\nwill result in division by 0 errors. Such errors occur as a blank variable is\ninterpreted as 0 when inside of $(())."]}),"\n",(0,i.jsx)(n.p,{children:"The following SLURM environment variables are the reason for this behaviour:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"SLURM_ARRAY_TASK_ID"}),"\n",(0,i.jsx)(n.li,{children:"SLURM_ARRAY_TASK_COUNT"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"A fair amount of effort would be required to get such scripts to work without\nthe use of SLRUM. One would need to remove the parallelisation set up sections\nand ensure that all files/models are being used/manipulated correctly in\nsubsequent sections/lines."}),"\n",(0,i.jsxs)(n.p,{children:["Please also note that the scripts rely on the array being 1 indexed.\n",(0,i.jsx)(n.code,{children:"--array=0-1"})," is technically the exact same as ",(0,i.jsx)(n.code,{children:"--array=1-2"}),", however the batch\nscripts require 1 indexing for the modular arithmetic to work correctly."]}),"\n",(0,i.jsx)(n.h2,{id:"time-and-memory-allocation",children:"Time and memory allocation"}),"\n",(0,i.jsxs)(n.p,{children:["SLURM workload manager allows one to set up a\npeak memory allocation parameter and a maximum wall time for the submitted job.\nThese parameters are specified in the ",(0,i.jsx)(n.code,{children:"#SBATCH"})," lines at the top of the\nscripts. If one executes the script normally, the absence of these should not\nmatter. One may want to implement artificial maximum wall times regardless as\nsome programs can take a long time to finish and cause too much memory pile up\n(resulting in a crash)."]}),"\n",(0,i.jsxs)(n.h2,{id:"module-purge-and-module-load",children:[(0,i.jsx)(n.code,{children:"module purge"})," and ",(0,i.jsx)(n.code,{children:"module load"})]}),"\n",(0,i.jsxs)(n.p,{children:["In most scripts you will see lines: ",(0,i.jsx)(n.code,{children:"module purge"})," and ",(0,i.jsx)(n.code,{children:"module load"}),". This is\ndue to the large quantity of software on the\nHPC systems here at UoE. These commands are a part of the 'Modules' tool and\nhelp with compatability between different programs. The setup file in the home\ndirectory of the repository gives one the option to remove all such lines\n(reccomended)."]})]})}function c(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>o});var i=t(7294);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);