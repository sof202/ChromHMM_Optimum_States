"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[763],{5172:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var t=i(5893),r=i(1151);const s={sidebar_position:8},o="SLURM information",a={id:"ChromOptimise/SLURM-Workload-Manager-Information",title:"SLURM information",description:"The scripts included in this repository were designed to be used with SLURM workload manager. As such, many elements of the scripts will not work if one does not run them through SLURM's sbatch command.",source:"@site/docs/ChromOptimise/SLURM-Workload-Manager-Information.md",sourceDirName:"ChromOptimise",slug:"/ChromOptimise/SLURM-Workload-Manager-Information",permalink:"/ChromOptimise/ChromOptimise/SLURM-Workload-Manager-Information",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"documentationSidebar",previous:{title:"Memory profiling",permalink:"/ChromOptimise/ChromOptimise/Memory-Profiling"}},l={},d=[{value:"<code>#SBATCH</code> lines",id:"sbatch-lines",level:2},{value:"Log files",id:"log-files",level:2},{value:"SLURM environment variables",id:"slurm-environment-variables",level:2},{value:"Arrays",id:"arrays",level:2},{value:"Time and memory allocation",id:"time-and-memory-allocation",level:2},{value:"<code>Module purge</code> and <code>Module load</code>",id:"module-purge-and-module-load",level:2}];function h(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"slurm-information",children:"SLURM information"}),"\n",(0,t.jsxs)(n.p,{children:["The scripts included in this repository were designed to be used with SLURM workload manager. As such, many elements of the scripts will not work if one does not run them through SLURM's ",(0,t.jsx)(n.code,{children:"sbatch"})," command.\n",(0,t.jsx)(n.br,{}),"\n","Here, we will outline the main areas of the code that depend on SLURM's ",(0,t.jsx)(n.code,{children:"sbatch"})," command in order to function correctly."]}),"\n",(0,t.jsxs)(n.h2,{id:"sbatch-lines",children:[(0,t.jsx)(n.code,{children:"#SBATCH"})," lines"]}),"\n",(0,t.jsxs)(n.p,{children:["At the top of every script (after the shebang) there are several comment lines that start: ",(0,t.jsx)(n.code,{children:"#SBATCH"}),". These lines are read by SLURM and give meta data on how the script should be ran. If running the script normally, these lines will be interpreted as comments, resulting in loss of functionality."]}),"\n",(0,t.jsx)(n.h2,{id:"log-files",children:"Log files"}),"\n",(0,t.jsxs)(n.p,{children:["The most important aspect that is lost when running scripts outside of ",(0,t.jsx)(n.code,{children:"sbatch"})," is the error logs. If one runs the scripts normally, all outputs, warnings and errors will be printed to the terminal.\n",(0,t.jsx)(n.br,{}),"\n","There will also be error messages from the hard links that are created in the SET UP section of each script (see ",(0,t.jsx)(n.a,{href:"/ChromOptimise/ChromOptimise/Configuration-Files-Setup#logfilemanagementsh",children:"LogFileManagement.sh"}),"). SLURM workload manager is unable to create folders in ",(0,t.jsx)(n.code,{children:"#SBATCH"})," lines and naming of log files is limited. As a result, log files are generated under temporary names and a hard link is made with a file with a more descriptive name (which allows for a more organised structure of your log files)."]}),"\n",(0,t.jsx)(n.h2,{id:"slurm-environment-variables",children:"SLURM environment variables"}),"\n",(0,t.jsxs)(n.p,{children:["Certain aspects of the scripts may lose there functionality if they depend on environment variables that are set up when running the script with SLURM's ",(0,t.jsx)(n.code,{children:"sbatch"})," command. Common SLURM environment variables that were used were:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"SLURM_SUBMIT_DIR -> This is the directory that the shell was in when the script was initially ran,"}),"\n",(0,t.jsx)(n.li,{children:"SLURM_JOB_ID -> This is the unique job identification number assigned to the job at creation,"}),"\n",(0,t.jsxs)(n.li,{children:["SLURM_JOB_NAME -> This is the name of the job as defined in the ",(0,t.jsx)(n.code,{children:"#SBATCH"})," lines."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Most instances of these variables are fine as they are not required for the script to function"}),"\n",(0,t.jsx)(n.h2,{id:"arrays",children:"Arrays"}),"\n",(0,t.jsxs)(n.p,{children:["For scripts that start with 'batch', the job is designed to be ran as a SLURM array (enabling parallelisation). If one does not run these scripts as an array through ",(0,t.jsx)(n.code,{children:"sbatch [script] --array=1-4"})," etc. then the script will fail. This is because the parallel processing logic that is applied in these scripts will result in division by 0 errors. Such errors occur as a blank variable is interpreted as 0 when inside of $(()).\n",(0,t.jsx)(n.br,{}),"\n","The following SLURM environment variables are the reason for this behaviour:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"SLURM_ARRAY_TASK_ID"}),"\n",(0,t.jsx)(n.li,{children:"SLURM_ARRAY_TASK_COUNT"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["A fair amount of effort would be required to get such scripts to work without the use of SLRUM. One would need to remove the parallelisation set up sections and ensure that all files/models are being used/manipulated correctly in subsequent sections/lines.\n",(0,t.jsx)(n.br,{}),"\n",(0,t.jsx)(n.br,{}),"\n","Please also note that the scripts rely on the array being 1 indexed. ",(0,t.jsx)(n.code,{children:"--array=0-1"})," is technically the exact same as ",(0,t.jsx)(n.code,{children:"--array=1-2"}),", however the batch scripts require 1 indexing for the modular arithmetic to work correctly."]}),"\n",(0,t.jsx)(n.h2,{id:"time-and-memory-allocation",children:"Time and memory allocation"}),"\n",(0,t.jsxs)(n.p,{children:["SLURM workload manager allows one to set up a peak memory allocation parameter and a maximum wall time for the submitted job. These parameters are specified in the ",(0,t.jsx)(n.code,{children:"#SBATCH"})," lines at the top of the scripts. If one executes the script normally, the absence of these should not matter. One may want to implement artificial maximum wall times regardless as some programs can take a long time to finish and cause too much memory pile up (resulting in a crash)."]}),"\n",(0,t.jsxs)(n.h2,{id:"module-purge-and-module-load",children:[(0,t.jsx)(n.code,{children:"Module purge"})," and ",(0,t.jsx)(n.code,{children:"Module load"})]}),"\n",(0,t.jsxs)(n.p,{children:["In most scripts you will see lines: ",(0,t.jsx)(n.code,{children:"Module purge"})," and ",(0,t.jsx)(n.code,{children:"Module load"}),". This is due to the large quantity of software on the HPC systems here at UoE. These commands are a part of the 'Modules' tool and help with compatability between different programs. The setup file in the home directory of the repository gives one the option to remove all such lines (reccomended)."]})]})}function c(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>o});var t=i(7294);const r={},s=t.createContext(r);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);